"""
Report Generator - Produces standalone HTML student feedback reports.
"""

import json
from html import escape
from typing import Any, Dict, List, Optional

from edmcp_regrade.core.regrade_job_manager import RegradeJobManager


class ReportGenerator:
    """Generates self-contained HTML feedback reports for students."""

    def __init__(self, job_manager: RegradeJobManager):
        self.job_manager = job_manager

    def generate_student_report(
        self, job_id: str, essay_id: int
    ) -> Dict[str, Any]:
        """Generate a standalone HTML report for a single essay."""
        job = self.job_manager.get_job(job_id)
        if not job:
            return {"status": "error", "message": f"Job not found: {job_id}"}

        essay = self.job_manager.get_essay(essay_id)
        if not essay:
            return {"status": "error", "message": f"Essay not found: {essay_id}"}
        if essay["job_id"] != job_id:
            return {"status": "error", "message": "Essay does not belong to this job"}

        html = self._build_html(job, essay)

        return {
            "status": "success",
            "job_id": job_id,
            "essay_id": essay_id,
            "student_identifier": essay.get("student_identifier", "Unknown"),
            "html": html,
        }

    def _build_html(self, job: Dict[str, Any], essay: Dict[str, Any]) -> str:
        """Build the complete standalone HTML document."""
        student = escape(essay.get("student_identifier", "Unknown"))
        job_name = escape(job.get("name", ""))
        assignment = escape(job.get("assignment_title", ""))

        # Determine final grade (teacher override or AI grade)
        final_grade = escape(essay.get("teacher_grade") or essay.get("grade") or "N/A")

        # Build sections
        rubric_section = self._build_rubric_section(essay)
        comments_section = self._build_comments_section(essay)
        essay_section = self._build_essay_section(essay)

        return f"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Feedback: {student} - {assignment or job_name}</title>
<style>
{self._get_css()}
</style>
</head>
<body>
<div class="container">
    <header>
        <h1>Essay Feedback Report</h1>
        <div class="meta">
            <div class="meta-item"><strong>Student:</strong> {student}</div>
            {"<div class='meta-item'><strong>Assignment:</strong> " + assignment + "</div>" if assignment else ""}
            {"<div class='meta-item'><strong>Class:</strong> " + escape(job.get('class_name', '')) + "</div>" if job.get('class_name') else ""}
            <div class="meta-item"><strong>Final Grade:</strong> <span class="grade">{final_grade}</span></div>
        </div>
    </header>

    {rubric_section}
    {comments_section}
    {essay_section}

    <footer>
        <p>Generated by Essay Regrade System</p>
    </footer>
</div>
</body>
</html>"""

    def _build_rubric_section(self, essay: Dict[str, Any]) -> str:
        """Build the criteria breakdown table."""
        eval_data = essay.get("evaluation")
        if not eval_data or not isinstance(eval_data, dict):
            return ""

        criteria = eval_data.get("criteria", [])
        if not criteria:
            return ""

        summary = escape(eval_data.get("summary", ""))

        rows = []
        for c in criteria:
            name = escape(str(c.get("name", "")))
            score = escape(str(c.get("score", "")))
            feedback = c.get("feedback", {})
            justification = escape(str(feedback.get("justification", "")))
            advice = escape(str(feedback.get("advice", "")))

            examples = feedback.get("examples", [])
            examples_html = ""
            if examples:
                items = "".join(f"<li>{escape(str(ex))}</li>" for ex in examples)
                examples_html = f"<ul class='examples'>{items}</ul>"

            rewritten = feedback.get("rewritten_example", "")
            rewritten_html = ""
            if rewritten:
                rewritten_html = f"<div class='rewritten'><strong>Suggested revision:</strong> {escape(str(rewritten))}</div>"

            rows.append(f"""
            <tr>
                <td class="criterion-name">{name}</td>
                <td class="criterion-score">{score}</td>
                <td class="criterion-feedback">
                    <p>{justification}</p>
                    {examples_html}
                    <p class="advice"><strong>Advice:</strong> {advice}</p>
                    {rewritten_html}
                </td>
            </tr>""")

        return f"""
    <section class="rubric-section">
        <h2>Rubric Breakdown</h2>
        {"<p class='summary'>" + summary + "</p>" if summary else ""}
        <table class="rubric-table">
            <thead>
                <tr>
                    <th>Criterion</th>
                    <th>Score</th>
                    <th>Feedback</th>
                </tr>
            </thead>
            <tbody>
                {"".join(rows)}
            </tbody>
        </table>
    </section>"""

    def _build_comments_section(self, essay: Dict[str, Any]) -> str:
        """Build the teacher comments section."""
        comments = essay.get("teacher_comments")
        annotations = essay.get("teacher_annotations")

        if not comments and not annotations:
            return ""

        parts = ['<section class="comments-section">', '<h2>Teacher Comments</h2>']

        if comments:
            parts.append(f"<div class='overall-comments'><p>{escape(str(comments))}</p></div>")

        if annotations:
            if isinstance(annotations, str):
                annotations = json.loads(annotations)
            if isinstance(annotations, list) and annotations:
                parts.append("<div class='annotations'><h3>Inline Notes</h3><ul>")
                for ann in annotations:
                    text = escape(str(ann.get("selected_text", "")))
                    comment = escape(str(ann.get("comment", "")))
                    parts.append(f"<li><span class='ann-quote'>\"{text}\"</span> &mdash; {comment}</li>")
                parts.append("</ul></div>")

        parts.append("</section>")
        return "\n".join(parts)

    def _build_essay_section(self, essay: Dict[str, Any]) -> str:
        """Build the annotated essay section with highlighted passages."""
        essay_text = essay.get("essay_text", "")
        if not essay_text:
            return ""

        annotations = essay.get("teacher_annotations")
        if isinstance(annotations, str):
            try:
                annotations = json.loads(annotations)
            except json.JSONDecodeError:
                annotations = None

        # Build annotated HTML
        annotated_html = self._apply_annotations(essay_text, annotations)

        return f"""
    <section class="essay-section">
        <h2>Student Essay</h2>
        <div class="essay-text">{annotated_html}</div>
    </section>"""

    def _apply_annotations(self, text: str, annotations: Optional[List[Dict[str, Any]]]) -> str:
        """Apply highlight annotations to essay text. Falls back to plain escaped text."""
        if not annotations or not isinstance(annotations, list):
            # No annotations â€” just escape and preserve paragraphs
            paragraphs = text.split("\n\n")
            return "".join(f"<p>{escape(p.strip())}</p>" for p in paragraphs if p.strip())

        # Build a list of (start, end, comment) for matched annotations
        matches = []
        for ann in annotations:
            selected = ann.get("selected_text", "")
            comment = ann.get("comment", "")
            if not selected:
                continue

            idx = text.find(selected)
            if idx == -1:
                # Try case-insensitive
                idx = text.lower().find(selected.lower())
            if idx >= 0:
                matches.append((idx, idx + len(selected), comment))

        # Sort by position, resolve overlaps (keep first)
        matches.sort(key=lambda m: m[0])
        filtered = []
        last_end = 0
        for start, end, comment in matches:
            if start >= last_end:
                filtered.append((start, end, comment))
                last_end = end

        # Build HTML with highlights
        parts = []
        pos = 0
        for start, end, comment in filtered:
            # Text before this highlight
            if start > pos:
                segment = text[pos:start]
                parts.append(self._text_to_html(segment))

            # Highlighted text
            highlighted = escape(text[start:end])
            tooltip = escape(comment)
            parts.append(
                f'<span class="highlight" title="{tooltip}">{highlighted}</span>'
            )
            pos = end

        # Remaining text
        if pos < len(text):
            parts.append(self._text_to_html(text[pos:]))

        return "".join(parts)

    def _text_to_html(self, text: str) -> str:
        """Convert plain text segment to HTML with paragraph breaks."""
        paragraphs = text.split("\n\n")
        result = []
        for p in paragraphs:
            stripped = p.strip()
            if stripped:
                result.append(f"<p>{escape(stripped)}</p>")
        return "".join(result) if result else escape(text)

    def _get_css(self) -> str:
        return """
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: Georgia, 'Times New Roman', serif;
    line-height: 1.6;
    color: #333;
    background: #f5f5f5;
}
.container {
    max-width: 800px;
    margin: 2rem auto;
    background: #fff;
    padding: 2rem 3rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    border-radius: 4px;
}
header { margin-bottom: 2rem; border-bottom: 2px solid #2c3e50; padding-bottom: 1rem; }
h1 { color: #2c3e50; font-size: 1.6rem; margin-bottom: 0.5rem; }
h2 { color: #2c3e50; font-size: 1.3rem; margin: 1.5rem 0 0.75rem; }
h3 { font-size: 1.1rem; margin: 0.75rem 0 0.5rem; }
.meta { display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.95rem; }
.meta-item { }
.grade { font-weight: bold; color: #2c3e50; font-size: 1.1em; }

/* Rubric Table */
.rubric-table { width: 100%; border-collapse: collapse; margin-top: 0.5rem; }
.rubric-table th, .rubric-table td { border: 1px solid #ddd; padding: 0.6rem 0.8rem; text-align: left; vertical-align: top; }
.rubric-table th { background: #2c3e50; color: #fff; font-weight: 600; }
.rubric-table tr:nth-child(even) { background: #f9f9f9; }
.criterion-name { font-weight: 600; width: 20%; }
.criterion-score { text-align: center; width: 10%; font-weight: bold; }
.criterion-feedback p { margin-bottom: 0.4rem; }
.examples { margin: 0.4rem 0 0.4rem 1.2rem; font-style: italic; color: #555; }
.advice { color: #1a5276; }
.rewritten { background: #eaf4e5; padding: 0.4rem 0.6rem; border-radius: 3px; margin-top: 0.4rem; font-size: 0.9rem; }
.summary { font-style: italic; margin-bottom: 0.75rem; color: #555; }

/* Teacher Comments */
.comments-section { background: #fefce8; border: 1px solid #f0e68c; border-radius: 4px; padding: 1rem 1.5rem; margin-top: 1.5rem; }
.overall-comments p { margin-bottom: 0.5rem; }
.annotations ul { list-style: none; padding: 0; }
.annotations li { margin-bottom: 0.5rem; padding-left: 1rem; border-left: 3px solid #d4a017; }
.ann-quote { font-style: italic; color: #555; }

/* Essay Section */
.essay-section { margin-top: 1.5rem; }
.essay-text { background: #fafafa; border: 1px solid #eee; border-radius: 4px; padding: 1.5rem; }
.essay-text p { margin-bottom: 1rem; text-indent: 2rem; }
.highlight {
    background: #fff3b0;
    border-bottom: 2px solid #d4a017;
    cursor: help;
    padding: 0 2px;
}
.highlight:hover { background: #ffe066; }

footer { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #eee; text-align: center; font-size: 0.8rem; color: #999; }

@media (max-width: 600px) {
    .container { padding: 1rem; margin: 0; }
    .meta { flex-direction: column; gap: 0.3rem; }
    .rubric-table { font-size: 0.85rem; }
}
"""
