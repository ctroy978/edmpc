"""
Report Generator - Produces standalone HTML student feedback reports.
"""

import json
from html import escape
from typing import Any, Dict, List, Optional

from edmcp_regrade.core.regrade_job_manager import RegradeJobManager


def _try_get_generated_flag(teacher_comments_raw: str) -> bool:
    """Return True if teacher_comments JSON has report_generated: true."""
    try:
        parsed = json.loads(teacher_comments_raw)
        return isinstance(parsed, dict) and bool(parsed.get("report_generated"))
    except (json.JSONDecodeError, TypeError):
        return False


class ReportGenerator:
    """Generates self-contained HTML feedback reports for students."""

    def __init__(self, job_manager: RegradeJobManager):
        self.job_manager = job_manager

    def generate_student_report(
        self, job_id: str, essay_id: int
    ) -> Dict[str, Any]:
        """Generate a standalone HTML report for a single essay."""
        job = self.job_manager.get_job(job_id)
        if not job:
            return {"status": "error", "message": f"Job not found: {job_id}"}

        essay = self.job_manager.get_essay(essay_id)
        if not essay:
            return {"status": "error", "message": f"Essay not found: {essay_id}"}
        if essay["job_id"] != job_id:
            return {"status": "error", "message": "Essay does not belong to this job"}

        html = self._build_html(job, essay)

        return {
            "status": "success",
            "job_id": job_id,
            "essay_id": essay_id,
            "student_identifier": essay.get("student_identifier", "Unknown"),
            "html": html,
        }

    def _build_html(self, job: Dict[str, Any], essay: Dict[str, Any]) -> str:
        """Build the complete standalone HTML document."""
        student = escape(essay.get("student_identifier") or "Unknown")
        job_name = escape(job.get("name") or "")
        assignment = escape(job.get("assignment_title") or "")

        # Determine final grade (teacher override or AI grade)
        final_grade = escape(essay.get("teacher_grade") or essay.get("grade") or "N/A")

        # Build sections
        rubric_section = self._build_rubric_section(essay)
        comments_section = self._build_comments_section(essay)
        essay_section = self._build_essay_section(essay)

        return f"""<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Feedback: {student} - {assignment or job_name}</title>
<style>
{self._get_css()}
</style>
</head>
<body>
<div class="container">
    <header>
        <h1>Essay Feedback Report</h1>
        <div class="meta">
            <div class="meta-item"><strong>Student:</strong> {student}</div>
            {"<div class='meta-item'><strong>Assignment:</strong> " + assignment + "</div>" if assignment else ""}
            {"<div class='meta-item'><strong>Class:</strong> " + escape(job.get('class_name') or '') + "</div>" if job.get('class_name') else ""}
            <div class="meta-item"><strong>Final Grade:</strong> <span class="grade">{final_grade}</span></div>
        </div>
    </header>

    {rubric_section}
    {comments_section}
    {essay_section}

    <footer>
        <p>Generated by Essay Regrade System</p>
    </footer>
</div>
</body>
</html>"""

    def _build_rubric_section(self, essay: Dict[str, Any]) -> str:
        """Build the unified feedback section as cards.

        One section, card format throughout:
        - First card: the merged teacher/AI overall feedback prose
        - Remaining cards: per-criterion breakdown with teacher score overrides applied
        """
        eval_data = essay.get("evaluation")
        if not eval_data or not isinstance(eval_data, dict):
            return ""

        criteria = eval_data.get("criteria", [])
        if not criteria:
            return ""

        # Extract teacher score overrides and per-criterion blended justifications
        teacher_overrides: dict = {}
        blended_justification_map: dict = {}
        tc_raw = essay.get("teacher_comments") or ""
        if tc_raw:
            try:
                parsed_tc = json.loads(tc_raw)
                if isinstance(parsed_tc, dict):
                    for o in parsed_tc.get("criteria_overrides", []):
                        cname = o.get("name", "")
                        cscore = o.get("score", "")
                        if cname and cscore:
                            teacher_overrides[cname] = cscore
                    if parsed_tc.get("report_generated") and parsed_tc.get("criteria_justifications"):
                        for item in parsed_tc["criteria_justifications"]:
                            iname = item.get("name", "")
                            ijust = item.get("blended_justification", "")
                            if iname and ijust:
                                blended_justification_map[iname] = ijust
            except (json.JSONDecodeError, TypeError):
                pass

        cards = []

        # Per-criterion cards with teacher score overrides applied
        for c in criteria:
            raw_name = str(c.get("name", ""))
            name = escape(raw_name)
            ai_score = str(c.get("score", ""))
            score = escape(teacher_overrides.get(raw_name, ai_score))

            feedback = c.get("feedback", {})
            if isinstance(feedback, dict):
                ai_justification = str(feedback.get("justification", ""))
                advice = escape(str(feedback.get("advice", "")))
                examples = feedback.get("examples", []) or []
            else:
                ai_justification = str(feedback) if feedback else ""
                advice = ""
                examples = []

            # Use blended justification if available, otherwise fall back to AI justification
            justification = escape(blended_justification_map.get(raw_name, ai_justification))

            just_html = (
                f'<p class="card-justification">\u2022 {justification}</p>'
                if justification else ""
            )
            advice_html = (
                f'<p class="card-advice">\u2022 {advice}</p>'
                if advice else ""
            )
            quote_html = ""
            if examples:
                first_quote = escape(str(examples[0]))
                quote_html = f'<blockquote class="card-quote">{first_quote}</blockquote>'

            cards.append(
                '<div class="feedback-card">'
                '<div class="card-header">'
                f'<span class="card-name">{name}</span>'
                f'<span class="card-score">{score}</span>'
                '</div>'
                f'{just_html}{advice_html}{quote_html}'
                '</div>'
            )

        return (
            '<section class="rubric-section">'
            '<h2>Feedback</h2>'
            + "".join(cards)
            + '</section>'
        )

    def _build_comments_section(self, essay: Dict[str, Any]) -> str:
        """Build the inline annotations section.

        Overall feedback prose is now integrated into the rubric section.
        This section only surfaces inline annotation notes, if any.
        """
        annotations = essay.get("teacher_annotations")
        if not annotations:
            return ""

        if isinstance(annotations, str):
            try:
                annotations = json.loads(annotations)
            except (json.JSONDecodeError, TypeError):
                return ""

        if not isinstance(annotations, list) or not annotations:
            return ""

        parts = ['<section class="comments-section">', '<h2>Inline Notes</h2>']
        parts.append("<ul>")
        for ann in annotations:
            text = escape(str(ann.get("selected_text", "")))
            comment = escape(str(ann.get("comment", "")))
            parts.append(f"<li><span class='ann-quote'>\"{text}\"</span> &mdash; {comment}</li>")
        parts.append("</ul>")
        parts.append("</section>")
        return "\n".join(parts)

    def _build_essay_section(self, essay: Dict[str, Any]) -> str:
        """Build the annotated essay section with highlighted passages."""
        essay_text = essay.get("essay_text", "")
        if not essay_text:
            return ""

        annotations = essay.get("teacher_annotations")
        if isinstance(annotations, str):
            try:
                annotations = json.loads(annotations)
            except json.JSONDecodeError:
                annotations = None

        # Build annotated HTML
        annotated_html = self._apply_annotations(essay_text, annotations)

        return f"""
    <section class="essay-section">
        <h2>Student Essay</h2>
        <div class="essay-text">{annotated_html}</div>
    </section>"""

    def _apply_annotations(self, text: str, annotations: Optional[List[Dict[str, Any]]]) -> str:
        """Apply highlight annotations to essay text. Falls back to plain escaped text."""
        if not annotations or not isinstance(annotations, list):
            # No annotations â€” just escape and preserve paragraphs
            paragraphs = text.split("\n\n")
            return "".join(f"<p>{escape(p.strip())}</p>" for p in paragraphs if p.strip())

        # Build a list of (start, end, comment) for matched annotations
        matches = []
        for ann in annotations:
            selected = ann.get("selected_text", "")
            comment = ann.get("comment", "")
            if not selected:
                continue

            idx = text.find(selected)
            if idx == -1:
                # Try case-insensitive
                idx = text.lower().find(selected.lower())
            if idx >= 0:
                matches.append((idx, idx + len(selected), comment))

        # Sort by position, resolve overlaps (keep first)
        matches.sort(key=lambda m: m[0])
        filtered = []
        last_end = 0
        for start, end, comment in matches:
            if start >= last_end:
                filtered.append((start, end, comment))
                last_end = end

        # Build HTML with highlights
        parts = []
        pos = 0
        for start, end, comment in filtered:
            # Text before this highlight
            if start > pos:
                segment = text[pos:start]
                parts.append(self._text_to_html(segment))

            # Highlighted text
            highlighted = escape(text[start:end])
            tooltip = escape(comment)
            parts.append(
                f'<span class="highlight" title="{tooltip}">{highlighted}</span>'
            )
            pos = end

        # Remaining text
        if pos < len(text):
            parts.append(self._text_to_html(text[pos:]))

        return "".join(parts)

    def _text_to_html(self, text: str) -> str:
        """Convert plain text segment to HTML with paragraph breaks."""
        paragraphs = text.split("\n\n")
        result = []
        for p in paragraphs:
            stripped = p.strip()
            if stripped:
                result.append(f"<p>{escape(stripped)}</p>")
        return "".join(result) if result else escape(text)

    def _get_css(self) -> str:
        return """
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: Georgia, 'Times New Roman', serif;
    line-height: 1.6;
    color: #333;
    background: #f5f5f5;
}
.container {
    max-width: 800px;
    margin: 2rem auto;
    background: #fff;
    padding: 2rem 3rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    border-radius: 4px;
}
header { margin-bottom: 2rem; border-bottom: 2px solid #2c3e50; padding-bottom: 1rem; }
h1 { color: #2c3e50; font-size: 1.6rem; margin-bottom: 0.5rem; }
h2 { color: #2c3e50; font-size: 1.3rem; margin: 1.5rem 0 0.75rem; }
h3 { font-size: 1.1rem; margin: 0.75rem 0 0.5rem; }
.meta { display: flex; flex-wrap: wrap; gap: 1rem; font-size: 0.95rem; }
.meta-item { }
.grade { font-weight: bold; color: #2c3e50; font-size: 1.1em; }

/* Feedback cards */
.feedback-card {
    border: 1px solid #e2e8f0;
    border-radius: 8px;
    padding: 12px 14px;
    margin-bottom: 10px;
    background: #f8fafc;
}
.card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 6px;
}
.card-name {
    font-weight: 600;
    font-size: 1em;
    color: #1e293b;
}
.card-score {
    background: #3b82f6;
    color: #fff;
    font-size: 0.8em;
    font-weight: bold;
    padding: 2px 8px;
    border-radius: 12px;
    white-space: nowrap;
}
.card-justification {
    margin: 0 0 4px 0;
    font-size: 0.9em;
    color: #334155;
    line-height: 1.7;
}
.card-advice {
    margin: 0 0 4px 0;
    font-size: 0.9em;
    color: #1d4ed8;
}
.card-quote {
    margin: 6px 0 0 0;
    padding: 6px 10px;
    border-left: 3px solid #94a3b8;
    color: #64748b;
    font-style: italic;
    font-size: 0.85em;
}

/* Inline annotations section */
.comments-section { margin-top: 1.5rem; }
.comments-section ul { list-style: none; padding: 0; }
.comments-section li { margin-bottom: 0.5rem; padding-left: 1rem; border-left: 3px solid #d4a017; }
.ann-quote { font-style: italic; color: #555; }

/* Essay Section */
.essay-section { margin-top: 1.5rem; }
.essay-text { background: #fafafa; border: 1px solid #eee; border-radius: 4px; padding: 1.5rem; }
.essay-text p { margin-bottom: 1rem; text-indent: 2rem; }
.highlight {
    background: #fff3b0;
    border-bottom: 2px solid #d4a017;
    cursor: help;
    padding: 0 2px;
}
.highlight:hover { background: #ffe066; }

footer { margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #eee; text-align: center; font-size: 0.8rem; color: #999; }

@media (max-width: 600px) {
    .container { padding: 1rem; margin: 0; }
    .meta { flex-direction: column; gap: 0.3rem; }
}
"""
